### 小结
>
- 第10～11两章分别介绍了Java程序从源码编译成字节码和从字节码编译成本地机器码的过程，Javac字节码编译器与虚拟机内的JIT编译器的执行过程合并起来其实就等同于一个传统编译器所执行的编译过程。
>
- 本章中，我们着重了解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果，还选择了几种常见的编译期优化技术进行讲解。对Java编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以帮我们处理的，哪些代码需要自己调节以便更适合编译器的优化。
>
### HotSpot 虚拟机内的即时编译器
- 解释器与编译器？各自优势？
- 分层编译策略？编译速度？编译质量？
>
### 编译对象与触发条件
- 热点代码？？两类？？
- 栈上替换？？
- 热点探测？？采样？？计数器？？hotspot采用？？
- 方法调用计数器？？
- 编译过程？？
- Client Compiler三段式编译器？？关注点？？
- Server Compiler是专门面向？的典型应用并为？特别调整过的编译器？
- 经典的优化动作？？与Java密切相关的优化技术？？激进优化？？
>
### 编译优化技术
- Java程序员有一个共识，以编译方式执行本地代码比解释方式更快，之所以有这样的共识，除去虚拟机解释执行字节码时额外消耗时间的原因外，还有一个很重要的原因就是虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中
- 因此一般来说，即时编译器产生的本地代码会比Javac产生的字节码更加优秀。优化一下：
>
```
static class B{
int value；
final int get（）{
  return value；
  }
}
public void foo（）{
  y=b.get（）；
  //……do stuff……
  z=b.get（）；
  sum=y+z；
}
```
>
- 方法内联——>冗余访问消除——>复写传播——>无用代码消除
>
- 语言无关的经典优化技术之一？
- 语言相关的经典优化技术之一？隐式开销？？隐式异常处理？？自动装箱消除？？
- 最重要的优化技术之一？	  作用？？重要性？？实方法？虚方法？守护内联？内联缓存？
- 最前沿的优化技术之一？      基本行为？方法逃逸？线程逃逸？
- 栈上分配？同步消除？标量替换？
>
```
int d=（c * b）*12+a+（a+b * c）；

if（foo！=null）{
  return foo.value；
}else{
  throw new NullPointException（）；
}

public static void foo（Object obj）{
  if（obj！=null）{
    System.out.println（"do something"）；
  }
}
public static void testInline（String[]args）{
  Object obj=null；
  foo（obj）；
}

```
>
- 优化之后？？？
>
### Java 与 C/C++ 的编译器对比
>
- 第一，因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。
- 第二，Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。
- 第三，Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即时编译器在进行一些优化（如前面提到的方法内联）时的难度要远大于C/C++的静态优化编译器。
- 第四，Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行，因为编译器无法看见程序的全貌，许多全局的优化措施都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时撤销或重新进行一些优化。
- 第五，Java语言中对象的内存分配都是堆上进行的，只有方法中的局部变量才能在栈上分配。而C/C++的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。
- Java语言的这些性能上的劣势都是为了换取开发效率上的优势而付出的代价，动态安全、动态扩展、垃圾回收这些“拖后腿”的特性都为Java语言的开发效率做出了很大贡献。
>
- 在C/C++中，别名分析（Alias Analysis）的难度就要远高于Java。
- Java编译器另外一个红利是由它的动态性所带来的，由于C/C++编译器所有优化都在编译期完成，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测（Call Frequency Prediction）、分支频率预测（Branch Frequency Prediction）、裁剪未被选择的分支（Untaken Branch Pruning）等，这些都会成为Java语言独有的性能优势。
>
### 命令行
- “-Xint”强制虚拟机运行于“解释模式”（Interpreted Mode）
- “-Xcomp”强制虚拟机运行于“编译模式”（Compiled Mode）
- “java [- Xint/-Xcomp] -version”命令的输出结果显示出这3种模式












