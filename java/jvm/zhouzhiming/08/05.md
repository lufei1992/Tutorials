### 5　本章小结
>
- 本章中，我们分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码，以及执行代码时涉及的内存结构。在第6、7、8三章中，我们针对Java程序是如何存储的、如何载入（创建）的，以及如何执行的问题把相关知识进行了讲解，第9章我们将一起看看这些理论知识在具体开发之中的经典应用。
>
- 所有的Java虚拟机的执行引擎都是一致的
- 输入的是？，处理过程？，输出的？
>
### 运行时栈帧结构
- ?是用于支持虚拟机进行?的数据结构，它是虚拟机？的？。栈帧存储了方法的？、？、？和？等信息。？从？开始至？完成的过程，都对应着一个？在？里面从？到？的过程。在编译程序代码的时候，栈帧中需要多大的？，多深的？都已经完全确定了，并且写入到？的？之中，
- 当前栈帧、当前方法
- ？是一组变量值存储空间，用于存放？和？。局部变量表的最大容量。？？最小单位？
>
##### 操作数栈
- 同局部变量表一样，操作数栈的最大深度也在编译的时候写入到?的?数据项中
- Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是?。
>
##### 动态链接
- 每个栈帧都包含一个指向？引用，持有这个引用是为了支持？。
>
##### 方法返回地址
- 两种返回方式？？返回到什么地方？
- 附加信息
>
### 方法调用
- 唯一任务？？
- 解析？五条指令？哪些解析阶段能确定？
- 分派？？静态分派？动态分派？静态类型？实际类型？
- 分派调用过程将会揭示多态性特征的一些最基本的体现，
- 虚拟机在重载时是通过参数的？而不是？作为判定依据的。并且？是编译期可知的，在编译阶段，Javac编译器会根据参数的？决定？版本
- 在运行期根据？确定方法执行版本的分派过程称为动态分派。
- 单分派与多分派？？方法的宗量？
- invokedynamic指令与前面4条“invoke*”指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。
>
### 基于栈的字节码执行引擎
- 解释执行？编译过程？？
- 基于栈的指令集与基于寄存器的指令集？指令集计算“1+1”？？对比？？
- 基于栈的解释器执行过程？？ 压入操作数栈、存入局部变量表、压入操作数栈
- stack=2, locals=4, 的含义是？？

















