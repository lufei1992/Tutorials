### 小结
>
- 在本章中，我们从编译器源码实现的层次上了解了Java源代码编译为字节码的过程，分析了Java语言中泛型、主动装箱/拆箱、条件编译等多种语法糖的前因后果，并实战练习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。
- 如本章概述中所说的那样，在前端编译器中，“优化”手段主要用于提升程序的编码效率，之所以把Javac这类将Java代码转变为字节码的编译器称做“前端编译器”，是因为它只完成了从程序到抽象语法树或中间字节码的生成，
- 而在此之后，还有一组内置于虚拟机内部的“后端编译器”完成了从字节码生成本地机器码的过程，即前面多次提到的即时编译器或JIT编译器，这个编译器的编译速度及编译结果的优劣，是衡量虚拟机性能一个很重要的指标。在第11章中，我们将会介绍即时编译器的运作和优化过程。
>
### javac编译器
- 编译过程3个部分？？？
- 解析与填充符号表     解析方法？？ 填充方法？？
- 注解处理器
- 语义分析与字节码生成  语义分析？？解语法糖？？字节码生成？？
>
### java语法糖
- 泛型与类型擦除？？
- 自动装箱、拆箱、遍历循环、边长参数
- 条件编译
- 自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法
- 变长参数，它在调用的时候变成了一个数组类型的参数，
- 包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们equals（）方法不处理数据转型的关系，
>

