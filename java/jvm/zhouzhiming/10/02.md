### Javac 编译器
>
- 分析源码是了解一项技术的实现内幕最有效的手段，Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯Java的程序员了解它的编译过程带来了很大的便利。
>
### 2.1 Javac的源码与调试
>
- ......
>
- 从SunJavac的代码来看，编译过程大致可以分为3个过程，分别是：
>
- 解析与填充符号表过程。
>
- 插入式注解处理器的注解处理过程。
>
- 分析与字节码生成过程。
>
- 这3个步骤之间的关系与交互顺序如图10-4所示。
>
![](https://github.com/lu666666/notebooks/blob/master/java/jvm/10/pic/04.png)
>
- Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile（）和compile2（）方法中，其中主体代码如图10-5所示，整个编译最关键的处理就由图中标注的8个方法来完成，下面我们具体看一下这8个方法实现了什么功能。
>
![](https://github.com/lu666666/notebooks/blob/master/java/jvm/10/pic/05.png)
>
### 2.2　解析与填充符号表
>
- 解析步骤由图10-5中的parseFiles（）方法（图10-5中的过程1.1）完成，解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。
>
#### 1.词法、语法分析
>
- **词法分析是将源代码的字符流转变为标记（Token）集合**，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。
- 在Javac的源码中，词法分析过程由 com.sun.tools.javac.parser.Scanner类来实现。
>
- **语法分析是根据Token序列构造抽象语法树的过程**，抽象语法树（Abstract SyntaxTree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。
>
- 图10-6是根据Eclipse AST View插件分析出来的某段代码的抽象语法树视图，读者可以通过这张图对抽象语法树有一个直观的认识。
- 在Javac的源码中，语法分析过程由com.sun.tools.javac.parser.Parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示，经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。
>
![](https://github.com/lu666666/notebooks/blob/master/java/jvm/10/pic/06.png)
>
#### 2.填充符号表
>
- 完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是图10-5中enterTrees（）方法（图10-5中的过程1.2）所做的事情。
- 符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，读者可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。
- 符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。
>
- 在Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。
>
### 2.3　注解处理器
>
- 在JDK 1.5之后，Java语言提供了对注解（Annotation）的支持，这些注解与普通的Java代
码一样，是在运行期间发挥作用的。
- 在JDK 1.6中实现了JSR-269规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。
- 如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是图10-4中的回环过程。
>
- 有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。
- 只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情，本章最后会给出一个使用插入式注解处理器的简单实战。
>
- 在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations（）方法中完成的，而它的执行过程则是在processAnnotations（）方法中完成的，这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing（）方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理。
>
### 2.4　语义分析与字节码生成
>
- 语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。
- 而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。举个例子，假设有如下的3个变量定义语句：
>
```
int a=1；
boolean b=false；
char c=2；
```
>
- 后续可能出现的赋值运算：
>
```
int d=a+c；
int d=b+c；
char d=a+c；
```
>
- 后续代码中如果出现了如上3种赋值运算的话，那它们都能构成结构正确的语法树，但是只有第1种的写法在语义上是没有问题的，能够通过编译，其余两种在Java语言中是不合逻辑的，无法编译（是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有意义。如在C语言中，a、b、c的上下文定义不变，第2、3种写法都是可以正确编译）。
>
#### 1.标注检查
>
- Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由图10-5中所示的attribute（）和flow（）方法（分别对应图10-5中的过程3.1和过程3.2）完成。
>
- 标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：
>
```
int a=1+2；
```
>
- 那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”，如图10-7所示，这个插入式表达式（Infix Expression）的值已经在语法树上标注出来了（ConstantExpressionValue：3）。
- 由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。
>
![](https://github.com/lu666666/notebooks/blob/master/java/jvm/10/pic/07.png)
>
- 标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类。
>
#### 2.数据及控制流分析
>
- 数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。
- 编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。下面举一个关于final修饰符的数据及控制流分析的例子，见代码清单10-1。
>
```
//方法一带有final修饰
public void foo（final int arg）{
final int var=0；
//do something
}
//方法二没有final修饰
public void foo（int arg）{
int var=0；
//do something
}
```
>
- 在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出来的Class文件是没有任何一点区别的，
- 通过第6章的讲解我们已经知道，局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。
- 因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。在Javac的源码中，数据及控制流分析的入口是图10-5中的flow（）方法（对应图10-5中的过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。
>
#### 3.解语法糖
>
- **语法糖**（Syntactic Sugar），也称糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J.Landin）发明的一个术语，指**在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用**。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。
>
- Java在现代编程语言之中属于“低糖语言”（相对于C#及许多其他JVM语言来说），尤其是JDK 1.5之前的版本，“低糖”语法也是Java语言被怀疑已经“落后”的一个表面理由。
- Java中最常用的**语法糖**主要是前面提到过的**泛型**（泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、**变长参数**、**自动装箱/拆箱**等，虚拟机运行时不支持这些语法，它们在**编译阶段还原回简单的基础语法结构**，这个过程称为解语法糖。Java的这些语法糖被解除后是什么样子，将在10.3节中详细讲述。
>
- 在Javac的源码中，解语法糖的过程由desugar（）方法触发，在com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。
>
#### 4.字节码生成
>
- 字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。
- 字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。
>
- 例如，前面章节中多次提到的**实例构造器**＜init＞（）方法和**类构造器**＜clinit＞（）方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected或private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），
- 这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，＜clinit＞（）方法中无须调用父类的＜clinit＞（）方法，虚拟机会自动保证父类构造器的执行，但在＜clinit＞（）方法中经常会生成调用java.lang.Object的＜init＞（）方法的代码）等操作收敛到＜init＞（）和＜clinit＞（）方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由Gen.normalizeDefs（）方法来实现。
- 除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 1.5）的append（）操作等。
>
- 完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass（）方法输出字节码，生成最终的Class文件，到此为止整个编译过程宣告结束。
>
#### 1 解析与填充符号表
-  parseFiles() 方法进行解析（词法分析、语法分析） 、 enterTrees（）方法填充符号表 
>
#### 2 插入式注解处理器的注解处理过程。
- 插入式注解处理器的初始化过程是在initPorcessAnnotations（）方法中完成的，执行过程则是在processAnnotations（）方法中完成的
>
#### 3 语义分析与字节码生成过程。
- 语义分析（标注检查、数据及控制流分析） 、 解语法糖 、 字节码生成
>






